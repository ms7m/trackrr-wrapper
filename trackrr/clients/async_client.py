# Trackrr.py (async.py)
# Trackrr's API Client

# Imports

import typing

import httpx
import json

from trackrr.ext.song import Song, TrackrrResult
from trackrr.errors import ParsingError
from trackrr.errors import InvalidAPIKey
from trackrr.errors import InvalidParams
from trackrr.errors import APIError, APIReturnedError

from trackrr.__version__ import __version__ as trackrr_version

class Trackrr:
    """ Represents a client used for requests 
    
    Args:
        api_key (str): Required key to interact with the Trackrr API
        version (str, optional): The API version. Default value is "v1"

    Raises:
        InvalidAPIKey (Exception): Raised when an API key is invalid/missing  
    """
    def __init__(self, api_key: str=None, version: str="v1"):
        if api_key is None:
            raise InvalidAPIKey("An API was not given/is required")

        self.session = None
        self.headers = { "X-Trackrr-APIKey": api_key, "X-Trackrr-Identifier": f"SyncPython - {trackrr_version}" }
        self.base_url = f"https://api.trackrr.cc/{version}"

    def create_session(self):
        """ Creates an aiohttp session """
        # Creating a session under an async function is recommended
        self.session = httpx.AsyncClient()

    async def send_request(self, url: str, params: dict) -> dict:
        """ Sends a request to the Trackrr API 
        This function will handle errors for the API

        You do not need to call this function directly

        Args:
            url (str): The request URL
            params (dict): Parameters given to the request

        Raises:
            ParsingError (Exception): Raised when a request can't be parsed

        Returns:
            dict: The contents of the request
        """

        url = self.base_url + url

        if self.session is None:
            # Create a session if one doesn't exist
            self.create_session()

        try:
            send_request = await self.session.get(url, params=params, headers=self.headers)
            if send_request.status_code == 502:
                raise APIError("Request returned a 502. This may mean the service is unavailable.")
            
            if send_request.status_code == 200:
                parse_request_to_json = send_request.json()
                return parse_request_to_json
        except json.JSONDecodeError:
            raise ParsingError(f"Issue with parsing the request from the API.")
        
        if send_request.status_code == 500:
            if send_request.headers.get("Content-Type") == "application/json":
                # This means that the error was probably generated by the API not the webserver or DNS.
                raise APIReturnedError("Server returned a 500.", request=send_request)
            else:
                raise APIError("Server returned a 500 with improper JSON output.")
        
        if send_request.status_code == 422:
            try:
                parse_request_to_json = send_request.json()
            
                _return_message = ["API Error:"]

                for validation_error in parse_request_to_json['detail']:
                    selected_line_of_code_data = validation_error['loc']
                    selected_loc_type = selected_line_of_code_data[0]
                    selected_loc_name = selected_line_of_code_data[1]

                    selected_line_of_code_message = validation_error['msg']
                    selected_line_of_code_type = validation_error['type']

                    _return_message.append(
                        f"{selected_loc_type} {selected_loc_name}: {selected_line_of_code_message} ({selected_line_of_code_type})"
                    )

                if _return_message == ["API_Error:"]:
                    raise InvalidParams("Service returned a validation error but there was no validation data found. This is probably a problem with the service.")

                if len(_return_message) > 1:
                    raise InvalidParams(", ".join(_return_message))
                
                raise InvalidParams(_return_message[0])


            except json.JSONDecodeError:
                raise InvalidParams("Service returned a validation error and another exception occurred when parsing the message.")




    async def search_isrc_code(self, isrc_code: str, filter_services: typing.Union[str, typing.List]=None, flags: str = None):
        current_params = {}

        if flags:
            current_params['flag'] = flags

        if filter_services:
            if isinstance(filter_services, str):
                raise ValueError("You cannot have only one service in filter services. If using multiple services, Please supply: ", "list")
            else:
                filtered_services = ",".join(filter_services)
                current_params['filteredServices'] = filtered_services

        current_params['isrcCode'] = isrc_code

        response = await self.send_request("/search/song/isrc", params=current_params)
        
        song_results = [Song(response['services'][x]) for x in response['meta']['servicesReturned']]
        services_returned = response['meta']['servicesReturned']
        return TrackrrResult(
            list_of_songs=song_results,
            services_returned=services_returned
        )


    async def search_song_by_url(self, url: str, filter_services: typing.Union[str, typing.List]=None, flags: str = None):
        current_params = {}

        if flags:
            current_params['flag'] = flags

        if filter_services:
            if isinstance(filter_services, str):
                raise ValueError("You cannot have only one service in filter services. If using multiple services, Please supply: ", "list")
            else:
                filtered_services = ",".join(filter_services)
                current_params['filteredServices'] = filtered_services

        current_params['url'] = url

        response = await self.send_request("/search/song/link", params=current_params)
        
        song_results = [Song(response['services'][x]) for x in response['meta']['servicesReturned']]
        services_returned = response['meta']['servicesReturned']
        return TrackrrResult(
            list_of_songs=song_results,
            services_returned=services_returned
        )


    async def search_song(self, search_query: str, filter_services: typing.Union[str, typing.List]=None, flags: str = None):
        current_params = {}

        if flags:
            current_params['flag'] = flags

        if filter_services:
            if isinstance(filter_services, str):
                raise ValueError("You cannot have only one service in filter services. If using multiple services, Please supply: ", "list")
            else:
                filtered_services = ",".join(filter_services)
                current_params['filteredServices'] = filtered_services

        current_params['query'] = search_query

        response = await self.send_request("/search/song", params=current_params)
        
        song_results = [Song(response['services'][x]) for x in response['meta']['servicesReturned']]
        services_returned = response['meta']['servicesReturned']
        return TrackrrResult(
            list_of_songs=song_results,
            services_returned=services_returned
        )

